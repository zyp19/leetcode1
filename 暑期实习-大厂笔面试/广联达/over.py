"""题目描述
给定一个长度为n的整数数组a，元素均不相同，问数组是否存在这样一个片段，只将该片段翻转就可以使整个数组升序排列。其中数组片段[l, r]
表示序列a[l], a[l + 1],...,a[r]。原始数组为
a[1], a[2], ..., a[l - 2], a[l - 1], a[l], a[l + 1], ..., a[r - 1], a[r], a[r + 1], a[r + 2], ..., a[n - 1], a[n]，
将片段[l, r]反序后的数组是a[1], a[2], ..., a[l - 2], a[l - 1], a[r], a[r - 1], ..., a[l + 1], a[l], a[r + 1], a[r + 2],
 ..., a[n - 1], a[n]。
输入:
第一行数据是一个整数：n (1≤n≤105)，表示数组长度。
第二行数据是n个整数a[1], a[2], ..., a[n] (1≤a[i]≤109)。
输出:
输出“yes”，如果存在；否则输出“no”，不用输出引号。
小狗Cheems的面前有一个有n张牌的牌堆，牌号为由1~n每个数字恰好出现一次。Cheems有一个序列，初始序列中有一张0号牌。现在是Cheems的回合，
Cheems准备抽牌，他打算每抽到一张牌就把这张牌放在这个序列的末尾，形成新的序列。它会重复抽牌直到牌堆中不剩下牌为止。于是他会得到一串长度为n+1的序列。
请问有多少不同的序列能满足以下的条件：
1. 序列以n为结尾
2. 序列中连续两张牌牌号的差的绝对值不能大于2
由于答案过大，答案对于998244353取模
"""
while 1:
    n = input()
    if n!="":
        n=int(n)
        a=[int(i) for i in input().split()]
        b=sorted(a)
        c=[a[i] for i in range(n) if a[i]!=b[i]]
        start=a.index(c[0])
        end=a.index(c[-1])
        if a[:start]+list(reversed(a[start:end+1]))+a[end+1:]==b:
            print("yes")
        else:
            print("no")
    else:
        break